# 运动规划功能实现计划

## 📋 项目概述

为18通道舵机驱动系统实现：
1. **梯形速度曲线** - 支持速度和加速度控制
2. **多点轨迹规划** - 支持最多50个路径点

## 🎯 功能目标

### 1. 梯形速度曲线
- ✅ 支持独立的速度参数（度/秒）
- ✅ 支持独立的加速度参数（度/秒²）
- ✅ 自动计算运动时间
- ✅ 3阶段运动：加速 → 匀速 → 减速
- ✅ 速度限制和安全检查

### 2. 多点轨迹规划
- ✅ 支持最多50个路径点
- ✅ 轨迹队列管理（添加、删除、清空）
- ✅ 自动点到点平滑过渡
- ✅ 轨迹预览和执行控制
- ✅ 支持循环播放

---

## 📐 阶段一：数据结构设计

### 1.1 运动参数结构
```c
// 运动参数（替代原来的duration）
typedef struct {
    float max_velocity;      // 最大速度 (度/秒)
    float acceleration;      // 加速度 (度/秒²)
    float deceleration;      // 减速度 (度/秒²)
    interp_type_t curve;     // 曲线类型
} motion_params_t;
```

### 1.2 轨迹点结构
```c
#define MAX_TRAJECTORY_POINTS 50  // 最多50个点

// 单个轨迹点
typedef struct {
    float position;          // 目标位置 (度)
    motion_params_t params;  // 运动参数
    uint32_t dwell_time_ms;  // 到达后停留时间（毫秒）
} trajectory_point_t;

// 轨迹队列
typedef struct {
    trajectory_point_t points[MAX_TRAJECTORY_POINTS];
    uint8_t count;           // 当前点数
    uint8_t current_index;   // 当前执行到第几个点
    bool loop;               // 是否循环执行
    bool running;            // 是否正在执行
} trajectory_queue_t;
```

### 1.3 扩展插值器结构
```c
typedef struct {
    // 原有字段保持
    float start_pos;
    float target_pos;
    float current_pos;
    // ... 其他字段 ...
    
    // 新增：梯形速度曲线参数
    motion_params_t motion_params;
    
    // 新增：梯形速度曲线状态
    float t_accel;           // 加速阶段时间
    float t_const;           // 匀速阶段时间
    float t_decel;           // 减速阶段时间
    float v_max_actual;      // 实际最大速度
    
    // 新增：轨迹队列
    trajectory_queue_t* trajectory;  // 指向轨迹队列（如果有）
} interpolator_t;
```

**内存占用估算**：
- `motion_params_t`: 16字节
- `trajectory_point_t`: 24字节
- `trajectory_queue_t`: 50点 × 24字节 + 开销 = ~1.2KB
- 18个轴的总增加: ~22KB (RP2350有264KB SRAM，完全够用)

---

## ⚙️ 阶段二：梯形速度曲线算法

### 2.1 运动规划计算
```
输入：
- start_pos: 起始位置
- target_pos: 目标位置
- max_velocity: 最大速度
- acceleration: 加速度
- deceleration: 减速度

计算步骤：
1. 计算移动距离: distance = |target_pos - start_pos|
2. 计算加速/减速距离: 
   - d_accel = v_max² / (2 × a)
   - d_decel = v_max² / (2 × d)
3. 判断能否达到最大速度：
   - 如果 d_accel + d_decel > distance: 三角形速度曲线
   - 否则: 标准梯形速度曲线
4. 计算各阶段时间: t_accel, t_const, t_decel
5. 总时间: t_total = t_accel + t_const + t_decel
```

### 2.2 位置计算函数
```c
float trapezoid_interpolate(interpolator_t* interp, float progress);
```

**算法逻辑**：
```
阶段1 (加速): 0 ≤ t < t_accel
  v(t) = a × t
  s(t) = 0.5 × a × t²
  
阶段2 (匀速): t_accel ≤ t < (t_accel + t_const)
  v(t) = v_max
  s(t) = s_accel + v_max × (t - t_accel)
  
阶段3 (减速): (t_accel + t_const) ≤ t < t_total
  v(t) = v_max - d × (t - t_accel - t_const)
  s(t) = s_accel + s_const + v_max × t' - 0.5 × d × t'²
```

---

## 🛤️ 阶段三：多点轨迹规划

### 3.1 轨迹队列管理
```c
// 初始化轨迹队列
void trajectory_init(trajectory_queue_t* traj);

// 添加轨迹点
bool trajectory_add_point(trajectory_queue_t* traj, 
                         float position, 
                         motion_params_t params,
                         uint32_t dwell_time_ms);

// 清空轨迹
void trajectory_clear(trajectory_queue_t* traj);

// 开始执行轨迹
bool trajectory_start(trajectory_queue_t* traj, bool loop);

// 停止执行
void trajectory_stop(trajectory_queue_t* traj);
```

### 3.2 轨迹执行逻辑
```
1. 从点A到点B
2. 到达点B后，停留dwell_time_ms
3. 自动开始从点B到点C
4. 重复直到最后一个点
5. 如果loop=true，回到第一个点继续
```

### 3.3 多轴协调
```c
// 18个轴同时执行各自的轨迹
typedef struct {
    trajectory_queue_t trajectories[SERVO_COUNT];
    bool sync_mode;  // 是否同步模式
} multi_axis_trajectory_t;
```

---

## 📡 阶段四：通信协议扩展

### 4.1 新增命令

#### 命令1：梯形速度运动
```c
#define CMD_MOVE_TRAPEZOID 0x21

// 数据格式
struct {
    uint8_t servo_id;
    int16_t target_angle;     // 目标角度 × 100
    uint16_t max_velocity;    // 最大速度 × 10 (度/秒)
    uint16_t acceleration;    // 加速度 × 10 (度/秒²)
    uint16_t deceleration;    // 减速度 × 10 (度/秒²)
}
```

#### 命令2：添加轨迹点
```c
#define CMD_TRAJECTORY_ADD_POINT 0x22

struct {
    uint8_t servo_id;
    int16_t position;         // 位置 × 100
    uint16_t max_velocity;    // 速度 × 10
    uint16_t acceleration;    // 加速度 × 10
    uint16_t deceleration;    // 减速度 × 10
    uint16_t dwell_time_ms;   // 停留时间
}
```

#### 命令3：轨迹控制
```c
#define CMD_TRAJECTORY_START 0x23  // 开始执行
#define CMD_TRAJECTORY_STOP  0x24  // 停止执行
#define CMD_TRAJECTORY_CLEAR 0x25  // 清空轨迹
```

### 4.2 协议修改
- 扩展`protocol.h`中的命令定义
- 更新`commands.c`中的命令处理函数
- 保持向后兼容（原有CMD_MOVE_SINGLE继续支持）

---

## 🖥️ 阶段五：上位机UI扩展

### 5.1 速度控制UI
```
每个舵机轨道增加控件：
[速度: 30 °/s] [加速度: 60 °/s²]
```

### 5.2 轨迹编辑器
```
新增窗口：轨迹编辑器
- 表格显示轨迹点列表
- 添加/删除/编辑点
- 预览轨迹曲线
- 执行/停止/循环控制
```

### 5.3 Python实现
```python
# serial_comm.py 新增方法
def move_trapezoid(self, servo_id, angle, velocity, accel):
    """梯形速度运动"""
    
def trajectory_add_point(self, servo_id, position, velocity, accel, dwell):
    """添加轨迹点"""
    
def trajectory_start(self, servo_id, loop=False):
    """开始轨迹"""
```

---

## 🧪 阶段六：测试计划

### 6.1 单元测试
- [ ] 梯形速度规划计算正确性
- [ ] 轨迹队列添加/删除/清空
- [ ] 边界条件测试（0点、1点、50点）

### 6.2 功能测试
- [ ] 单轴梯形速度运动
- [ ] 多轴协调运动
- [ ] 单点轨迹（退化为点到点）
- [ ] 多点轨迹（2点、10点、50点）
- [ ] 循环轨迹

### 6.3 性能测试
- [ ] CPU占用率 < 5%
- [ ] 内存占用检查
- [ ] 20ms插值周期稳定性

---

## 📅 实施时间表

| 阶段 | 任务 | 预计时间 | 状态 |
|------|------|---------|------|
| Phase 1 | 数据结构设计 | 1小时 | ⏳ 待开始 |
| Phase 2 | 梯形速度算法 | 2-3小时 | ⏳ 待开始 |
| Phase 3 | 多点轨迹实现 | 2-3小时 | ⏳ 待开始 |
| Phase 4 | 通信协议扩展 | 1-2小时 | ⏳ 待开始 |
| Phase 5 | 上位机UI | 2-3小时 | ⏳ 待开始 |
| Phase 6 | 测试和优化 | 2小时 | ⏳ 待开始 |
| **总计** | | **10-14小时** | |

---

## 🔧 技术要点

### 内存优化
- 轨迹队列按需分配
- 未使用轨迹功能时零开销

### 实时性保证
- 所有计算在20ms插值周期内完成
- 关键路径优化

### 安全性
- 速度/加速度限制检查
- 位置边界检查（0-180度）
- 运动平滑过渡，防止突变

---

## ✅ 完成标准

1. ✅ 梯形速度曲线运行正常
2. ✅ 支持50点轨迹
3. ✅ 上位机UI完整可用
4. ✅ 全部测试通过
5. ✅ 文档完善

---

## 📝 备注

- 保持向后兼容性
- 代码遵循现有风格
- 充分的注释和文档
- 分步提交，便于回滚

